---
title: "Introduction to ddfr"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to ddfr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette provides a short introduction to the `ddfr` package.
I apologize for it not being typeset beautifully, however as I created
this package for an exercise sheet submission at university, I'm bound by time
constraints.

Nevertheless, this vignette, together with the documentation usable within `R`
by `?` should be more than enough in order to get started with this package.
_Every_ function listed below has a dedicated help page in `R` which should
hopefully provide you with all relevant information.
You can also check out the
[Reference](https://fdf-uni.github.io/ddfr/reference/index.html) on the website.

Lastly, thanks a lot for checking out my package! :)

# Overview

After having installed the package (most probably from GitHub), it can be loaded
in `R` using the following command:
```{r setup}
library(ddfr)
```

The focus of the package is working with the custom S4 class `ddf` which
provides a convenient way to work with discrete distributions with finite
support in `R`.

It has three slots called `supp`, `probs` and `desc` which, in that order, give
the support of the distribution, the corresponding probabilities and a short
description of the respective distribution.
They can all be accessed using the getters `supp()`, `probs()` and `desc()`.
For the description there is also a setter such that it can easily be changed:

```{r}
mydist <- ddf(1:6, rep(1 / 6, 6), "A first description")
mydist
supp(mydist)
desc(mydist) <- "This description fits better"
mydist
```

# Creating new `ddf` objects

## Manually

The intended way to create custom new `ddf` objects is to use the provided
function with the same name. It takes as its arguments a numerical vector
specifying the support of the distribution, a second numerical vector of the
same length containing the corresponding probabilities and lastly, an optional
description of the distribution.

For example, to create a distribution modeling a single throw of a fair
six-sided dice, one can use:
```{r}
ddf(1:6, rep(1 / 6, 6), "A distribution modeling a single dice throw")
```

Note that the probabilities have to approximately sum up to $1$ or otherwise the
function throws an error. While this might change in the future, in the current
implementation, the error has to be less than `1e-10`:
```{r}
# Probabilities don't sum up to â‰ˆ1
try(ddf(1, 1 - 1e-10))

# This works
ddf(1, 1 - 1e-11)
```

In case one does not have probabilities, but absolute frequencies instead, one
can also use `ddf_from_frequencies()` as an alternative. For example, the
following creates a `ddf` object from hypothetical counts of throwing a
six-sided dice one hundred times:
```{r}
ddf_from_frequencies(1:6, c(19, 14, 17, 18, 15, 17), "My dice throws")
```
As one can see, the arguments are mostly the same except for passing the
frequencies instead of the probabilities as the second argument.

For more details on both methods please consult the documentation of `ddf()` and
`ddf_from_frequencies()`, respectively.

## Using the already implemented distributions

`ddfr` already provides you with a large amount of common discrete distributions.
The below list shows the currently implemented discrete distributions with
finite support.
To learn more about any single one of them, use the help in `R`, e.g. `?bin()`.
Once again I'd like to mention the 
[Reference](https://fdf-uni.github.io/ddfr/reference/index.html)
as it might also be a convenient way to find a specific distribution you're
looking for.

- Discrete uniform distribution as `unif()`
- Bernoulli distribution as `bernoulli()`
- Binomial distribution as `bin()`
- Rademacher distribution as `rademacher()`
- Benford's law as `benford()`
- Zipf distribution as `zipf()`
- Hypergeometric distribution as `hypergeometric()`
- Negative hypergeometric distribution as `negative_hypergeometric()`
- Beta-binomial distribution as `beta_binomial()`

Furthermore, there are also functions to create approximations of the following
three discrete distributions with countably infinite support.

- Poisson distribution as `pois()`
- Negative binomial distribution as `negative_bin()`
- Geometric distribution as `geometric()`

The approximation works by finding a large enough number $r > 0$ such that
cutting of the support after $r$ yields an overall probability which is within
a given range $\epsilon$ of $1$. The default value for $\epsilon$ is `1e-10`,
however this can be customized using the `eps` argument.
Unless the `normalize` argument is manually set to `FALSE` (by default it is
`TRUE`) the approximation is then also normalized such that the sum of
all probabilities becomes precisely one.
The following examples demonstrate this, however, for further details you might
also want to check out the respective documentation of the function you're using.
```{r}
# Approximation of the Poisson distribution
# to demonstrate the `normalize` argument
p <- pois(20, normalize = FALSE)

# Not equal to one (but still pretty close):
1 - sum(probs(p))

# Note how the `normalize` argument here could be omitted
# since it is `TRUE` by default
p_normalized <- pois(20, normalize = TRUE)

# Now the summed probabilities are equal to one:
1 - sum(probs(p_normalized))


# For most cases, something like this should suffice
geometric(0.8)

# However, you can of course increase the accuracy if you want to
geometric(0.8, eps = .Machine$double.eps)
```

## From other `ddf` objects

Lastly, there is also the possibility to use already existing `ddf` objects to
create new ones.
Currently there are only two functions for doing so.

The first one is the generic method `-` with which the support of a distribution
can be multiplied with $-1$:
```{r}
-bin(5, 0.8)
```

The second one is the function `shift()` with which the support of a
distribution can be shifted by a specified amount:
```{r}
shift(unif(3), 3)
```

# Analysis of distributions

`ddfr` provides many ways to analyze a given distribution.
This section only lists the corresponding functions.
For details, the respective documentations should hopefully suffice.

## Central tendency
- Expected value as `expected_value()` or generic `mean()`
- Medians as `medians()` (plural form as they aren't necessarily unique)
- Modes as `modes()` (plural form as they aren't necessarily unique)

## Dispersion
- Standard deviation as `standard_deviation()`
- Variance as `variance()`
- Interquartile range as `iqr()`
- Range as `distribution_range()`

## Moments

- $n$-th raw moment as `moment()`
- $n$-th central moment as `central_moment()`
- $n$-th standardized moment as `standardized_moment()`

Besides this, there are also additional functions for calculating other often
used moments (besides the already mentioned variance):

- Skewness as `skew()`
- Kurtosis as `kurtosis()`
- Excess kurtosis as `excess_kurtosis()`

## Quantiles

- Quantiles as `quantiles()`
- Percentiles as `percentile()`
- Deciles as `decile()`
- Quartiles as `quartile()`

## Entropy
- Entropy as `entropy()`

## Report
In case one wants to quickly get an overview of the considered distribution,
there is also the function `report()` which, as the name suggests, writes a
report on the given distribution involving most of the above properties.
The following example demonstrates this (please not that for the purpose of
better readability, the output is printed as normal text):
```{r, results='asis'}
cat(report(bin(15, 0.7)))
```

# Creating New Objects from `ddf` Distributions

## Creating `R` functions

One can use `pmf` and `cdf` to get `R` functions behaving like the probability
mass function and cumulative distribution function for a given distribution,
respectively.
Especially the first of these two is rather useful as it can be used to get the
probability of any number:
```{r}
# Probability of 5 in a binomial distribution with parameters n = 10 and p = 0.7
pmf(bin(10, 0.7))(5)
```
Note that this also works for numbers which are _not_ part of a distribution's
support, in which case the function simply returns $0$:
```{r}
pmf(bin(10, 0.7))(3.5)
```


## Sampling

Use `samples()` to create samples based on a distribution.
For example, one can simulate 10 fair dice throws as follows:
```{r}
samples(unif(6), 10)
```
This function was also used to generate the frequency table for dice throws
above in the "Creating new `ddf` objects" section.

# Plotting

`ddfr` also provides extensive plotting capabilities via the three functions
`plot()`, `plot_pmf()` and `plot_cdf()`.
The first one of these is once again a generic for the S4 class `ddf`.

At least when it comes to plots, an image is worth a thousand words, so here are
all three functions in action:
```{r}
#| fig.alt: >
#|    Three plots for a binomial distribution with parameters n = 30 and p = 0.3.
#|    The first plot visualizes it as a column chart.
#|    The second plot shows its probability mass funtion using a line plot with points corresponding to the support of the distribution being highlighted additionally as small circles.
#|    The third and last plot shows its cumulative distribution function as a line plot having the form of a step function. The steps correspond to points of the support of the distribution and they're once again highlighted in the same way.
plot(bin(30, 0.3))
plot_pmf(bin(30, 0.3))
plot_cdf(bin(30, 0.3))
```


# Convolutions

Lastly, there is the possibility to calculate convolutions of distributions.
For example, to compute the distribution of the sum of two six-sided dice when
tossed together, one can use
```{r}
conv(unif(6), unif(6))

# Short hand using *
unif(6) * unif(6)
```
The second example shows how the generic `*` has also been defined for objects
from the `ddf` class to quickly convolve distributions.

The function `conv_n()` calculates the $n$-th fold convolution of a distribution
with itself, see `?conv_n()` for details.

Lastly, there is also the function `convolve_cpp()` which is the underlying
implementation for the convolution using `Rcpp` for better performance.
It is not really intended for use with `ddfr` objects directly, but might still
be useful in other applications.
